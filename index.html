<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Properties Map</title>
  <style>
    .map-wrap {
      width: 100%;
      max-width: 1000px;
      margin: 24px auto;
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .hint { max-width: 1000px; margin: 0 auto; padding: 0 16px; color: #333; }
    code { background:#f4f4f5; padding:2px 6px; border-radius:6px; }

    .infowin { max-width: 280px; }
    .infowin h3 { margin: 0 0 8px 0; font-size: 16px; }
    .infowin img { display: block; width: 100%; height: auto; border-radius: 8px; margin: 8px 0; }
    .infowin p { margin: 4px 0; }
    .infowin .price { font-weight: 600; }

    /* Filter control styled like native Map/Satellite and attached to its right */
    .filter-control { font-family: inherit; }
    .filter-control .fc-wrap {
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 2px;
      box-shadow: 0 1px 4px rgba(0,0,0,.24);
      margin: 10px 0 0 0; /* default; we'll collapse gap next to map type control */
      display: inline-flex;
      align-items: center;
      position: relative;
      height: 40px; /* align height with native control */
    }
    /* Sit flush to the right of the native Map/Satellite control (no gap, shared border) */
    .gm-style .gm-style-mtc + .filter-control .fc-wrap { margin-left: -1px; border-left: none; border-radius: 0 2px 2px 0; }

    .filter-control button {
      background: transparent;
      border: 0;
      padding: 0 14px;
      height: 100%;
      cursor: pointer;
      font-weight: 600;
      line-height: 40px;
      font-size: 16px;
    }
    .filter-control button:hover { background: #f1f3f4; }

    .filter-control .menu {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 6px;
      background: #fff;
      border: 1px solid #dadce0;
      border-radius: 2px;
      box-shadow: 0 2px 8px rgba(0,0,0,.24);
      padding: 8px 10px;
      display: none;
      z-index: 5;
      min-width: 180px;
    }
    .filter-control .menu label { display: flex; align-items: center; gap: 8px; padding: 4px 0; font-size: 13px; }

    /* Prevent scrollbars when embedded in an iframe */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    .map-wrap, #map, .gm-style {
      overflow: hidden !important;
    }
  </style>
</head>
<body>
  <div class="map-wrap">
    <div id="map" style="height: 600px; width: 100%;"></div>

    <script async
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAICOnPq_rKDMXcA5WF5huQWRskOag-ENQ&callback=initMap">
    </script>

    <script>
      async function initMap() {
        const US_CENTER = { lat: 38.5, lng: -96.5 };
        const US_ZOOM = 4.0;

        const map = new google.maps.Map(document.getElementById("map"), {
          zoom: US_ZOOM,
          center: US_CENTER,
          streetViewControl: false
        });

        const recenterOnUS = () => {
          map.setCenter(US_CENTER);
          if (map.getZoom() !== US_ZOOM) map.setZoom(US_ZOOM);
        };
        // Continental US bounds as a LatLngBounds instance (more reliable)
        const USA_BOUNDS = new google.maps.LatLngBounds(
          new google.maps.LatLng(24.7433195, -124.7844079),
          new google.maps.LatLng(49.3457868,  -66.9513812)
        );

        // Add some padding around US so popups near the borders aren't clipped
        const VIEW_BOUNDS = new google.maps.LatLngBounds(
          new google.maps.LatLng(5,  -140),   // more room south & west
          new google.maps.LatLng(72,  -50)    // much more room north & east
        );

        // Keep users roughly within North America but allow more zoom-out
        map.setOptions({
          restriction: { latLngBounds: VIEW_BOUNDS, strictBounds: false },
          minZoom: 2
        });
        map.setOptions({
          mapTypeControl: true,
          mapTypeControlOptions: {
            style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
            position: google.maps.ControlPosition.TOP_LEFT
          }
        });

        const sheetId = "1UU6QeID1wbqugVXkJJM6DWZpHhzqKUuCYarKB-SWK0I";
        const gid = "283380080";
        const url = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json&gid=${gid}`;

        const response = await fetch(url);
        const text = await response.text();
        const json = JSON.parse(text.substring(47, text.length - 2));
        const rows = json.table.rows;

        const infoWindow = new google.maps.InfoWindow();
        const bounds = new google.maps.LatLngBounds();

        const markers = [];

        // Create a Filter control and place it immediately to the right of Map/Satellite (TOP_LEFT)
        const filterDiv = document.createElement('div');
        filterDiv.className = 'filter-control';
        const fcWrap = document.createElement('div');
        fcWrap.className = 'fc-wrap';
        const fcBtn = document.createElement('button');
        fcBtn.type = 'button';
        fcBtn.textContent = 'Filter';
        fcWrap.appendChild(fcBtn);
        const fcMenu = document.createElement('div');
        fcMenu.className = 'menu';
        fcMenu.innerHTML = `
          <label><input type="checkbox" id="fc-hide-available"> Hide Available</label>
          <label><input type="checkbox" id="fc-hide-sold"> Hide Sold</label>
        `;
        fcWrap.appendChild(fcMenu);
        filterDiv.appendChild(fcWrap);
        map.controls[google.maps.ControlPosition.TOP_LEFT].push(filterDiv);

        // Toggle menu open/close; keep open when clicking inside
        fcBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          fcMenu.style.display = (fcMenu.style.display === 'block') ? 'none' : 'block';
        });
        document.addEventListener('click', (e) => {
          if (!fcWrap.contains(e.target)) fcMenu.style.display = 'none';
        });

        function applyFilters() {
          const hideAvail = document.getElementById('fc-hide-available')?.checked;
          const hideSold  = document.getElementById('fc-hide-sold')?.checked;
          markers.forEach(m => {
            const hide = (m.isSold && hideSold) || (!m.isSold && hideAvail);
            m.setVisible(!hide);
          });
        }
        fcMenu.addEventListener('change', applyFilters);


        rows.forEach(r => {
          const status = (r.c[0]?.v || "").trim();
          const title = r.c[1]?.v || "";
          const price = r.c[2]?.v || "";
          const address = r.c[3]?.v || "";
          const acres = r.c[4]?.v || "";
          const lat = parseFloat(r.c[5]?.v) || 0;
          const lng = parseFloat(r.c[6]?.v) || 0;
          const link = r.c[7]?.v || "#";
          const photo = r.c[8]?.v || "https://placehold.co/800x500?text=No+Image";

          if (!lat || !lng) return;

          const normalizedStatus = (status || "").toLowerCase().trim();
          const validStatuses = ["full marketing", "sale pending", "basic marketing", "sold"];
          const matchedStatus = validStatuses.find(s => normalizedStatus.startsWith(s));
          if (!matchedStatus) return;

          // Clean display name
          let displayStatus = status;
          if (/^(basic marketing|full marketing)$/i.test(status)) {
            displayStatus = "Available";
          } else if (/^sale pending/i.test(status)) {
            displayStatus = "Sale Pending";
          }

          const isSold = normalizedStatus === 'sold';

          // Color: SOLD = rojo, el resto = azul
          const iconUrl = normalizedStatus === "sold"
            ? "https://maps.google.com/mapfiles/ms/icons/red-dot.png"
            : "https://maps.google.com/mapfiles/ms/icons/blue-dot.png";

          const marker = new google.maps.Marker({
            position: { lat, lng },
            map,
            title,
            icon: iconUrl,
            zIndex: normalizedStatus === "sold" ? 1 : 2
          });
          marker.isSold = isSold; // for filtering
          markers.push(marker);

          marker.addListener("click", () => {
            const container = document.createElement("div");
            container.className = "infowin";
            container.innerHTML = `
              <h3>${title}</h3>
              <img id="iw-img" src="${photo}" alt="Featured photo for ${title}">
              <p><strong>Status:</strong> ${displayStatus}</p>
              <p><strong>Address:</strong> ${address}</p>
              <p><strong>Size:</strong> ${acres} acres</p>
              <p><strong>Price:</strong> ${formatPrice(price)}</p>
              <p><a href="${link}" target="_blank">View Property</a></p>
            `;

            const img = container.querySelector('#iw-img');
            if (img) {
              img.addEventListener('load', () => infoWindow.setContent(container));
              img.addEventListener('error', () => {
                img.src = 'https://placehold.co/800x500?text=No+Image';
                infoWindow.setContent(container);
              });
            }

            infoWindow.setContent(container);
            infoWindow.open({ map, anchor: marker });
            // Ensure the InfoWindow is fully visible only if it's actually offscreen
            google.maps.event.addListenerOnce(infoWindow, 'domready', () => {
              const mapEl = document.getElementById('map');
              const iwEl = document.querySelector('.gm-style-iw');
              if (!mapEl || !iwEl) return;

              setTimeout(() => {
                const pad = 12;
                const mr = mapEl.getBoundingClientRect();
                const iwFrame = iwEl.closest('div[role="dialog"]') || iwEl;
                const ir = iwFrame.getBoundingClientRect();

                let dx = 0, dy = 0;

                // Only pan if the InfoWindow is actually cropped out of view
                if (ir.top < mr.top + pad) dy = (mr.top + pad) - ir.top; // offscreen above
                else if (ir.bottom > mr.bottom - pad) dy = (mr.bottom - pad) - ir.bottom; // offscreen below

                if (ir.left < mr.left + pad) dx = (mr.left + pad) - ir.left; // offscreen left
                else if (ir.right > mr.right - pad) dx = (mr.right - pad) - ir.right; // offscreen right

                if (dx !== 0 || dy !== 0) {
                  map.panBy(dx, dy);
                }
              }, 250);
            });
          });

          bounds.extend(marker.getPosition());
        });

        google.maps.event.addListenerOnce(map, 'idle', () => {
          const center = map.getCenter();
          if (!VIEW_BOUNDS.contains(center)) {
            map.setCenter(US_CENTER); // keep within permitted viewport
          }
          recenterOnUS();
        });

        map.fitBounds(USA_BOUNDS);
        if (typeof applyFilters === 'function') applyFilters();
      }

      function formatPrice(value) {
        if (!value) return '$0';
        // Remove any existing non-numeric characters except '.'
        const num = parseFloat(String(value).replace(/[^0-9.]/g, ''));
        if (isNaN(num)) return value;
        return num.toLocaleString('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0 });
      }
    </script>
  </div>
</body>
</html>
